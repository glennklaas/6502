;GAKMON v1.0 - 6502 Monitor
	.ORG $300
	
;Simulator IO
io_area	= $e000
io_cls	= io_area + 0	; clear terminal window
io_putc	= io_area + 1	; put char
io_putr	= io_area + 2	; put raw char (doesn't interpret CR/LF)
io_puth	= io_area + 3	; put as hex number
io_getc	= io_area + 4	; get char
io_xpos = io_area + 5	; cursor X position
io_ypos = io_area + 6	; cursor Y position

;GENERAL EQUATES
;	ACIA 		:= $A000	;BASE ADDRESS OF THE MC68B50P
;	ACIAControl 	:= ACIA+0	; Set operational parameters (w)     
;	ACIAStatus 	:= ACIA+0	; Indicates if char has been received (r)
;	ACIAData 	:= ACIA+1	; Data being recieved (r) or sent (w)

;ZP VARIABLES
STACK_TOP 	= $FF		;
XAML		= $10		;LAST "OPENED" LOCATION LOW
XAMH		= $11		;LAST "OPENED" LOCATION HIGH
STL		= $12		;STORE ADDRESS LOW
STH		= $13		;STORE ADDRESS HIGH
L		= $14		;HEX VALUE PARSING LOW
H		= $15		;HEX VALUE PARSING HIGH
YSAV		= $16		;USED TO SEE IF HEX VALUE IS GIVEN
MODE		= $17		;$00=XAM, $7F=STOR, $AE=BLOCK XAM
MSGL		= $18		;MSG START ADDRESS
MSGH		= $19		;MSG END ADDRESS

;NON-ZP VARIABLES
IN		= $200		;INPUT BUFFER

;CONSTANTS
BS		= $08		;CODE-BACKSPACE KEY
CR		= $0D		;CODE-CARRIAGE RETURN
LF		= $0A 		;CODE-LINE FEED
ESC		= $1B		;CODE-ESC KEY
PROMPT		= '/'		;WOZ PROMPT

;.segment "CODE"
;.org $C000

RESET:
	CLD
	LDX	#STACK_TOP
	TXS	
;	LDA	#$95	; Set ACIA:CLK/16,8bit,1stp,RTS low TX INT disabled
;	STA	ACIAControl

;DISPLAY WELCOME MESSAGE	
	LDA #<MSG1     ;DETERMINE LOW
	STA MSGL       ;SET LOW
	LDA #>MSG1     ;DETERMINE HI
	STA MSGH       ;SET HI
	JSR SHWMSG     ;SHOW WELCOME
	
;THE GETLINE PROCESS
SFTRST:	LDA #ESC       ;AUTO ESCAPE
NOTCR:	CMP #BS        ;BACKSPACE KEY?
	BEQ BAKSPACE   ;YES
	CMP #ESC       ;ESC?
	BEQ ESCAPE     ;YES
	INY            ;ADVANCE TEXT INDEX
	
	BPL NEXTCHAR   ;AUTO ESC IF LINE LONGER THAN 127	
ESCAPE:	LDA #PROMPT    ;PRINT PROMPT CHARACTER
	JSR ECHO       ;OUTPUT IT

GETLINE: 
	LDA #LF
	JSR ECHO
	LDA #CR       ;SEND CR
	
	JSR ECHO
	LDY #$01       ;INITIALIZE TEXT INDEX

BAKSPACE: 
	DEY
	BMI GETLINE    ;BEYOND START OF LINE, REINIT
	LDA #' '       ;SPACE, OVERWITE CHAR
	JSR ECHO
	
	LDA #BS        ;BACKSPACE AGAIN
	JSR ECHO

NEXTCHAR: 
	JSR RDKEY	;WAIT FOR KEYPRESS
	STA IN,Y	;ADD TO TEXT BUFFER
	JSR ECHO	;DISPLAY CHARACTER
	;JSR PRBYTE	;  DEBUG 
	CMP #CR		;CR?
	BNE NOTCR	;NO.

;*********************************
;LINE RECEIVED, NOW LET'S PARSE IT
;*********************************
	
	LDY #$FF	;RESET TEXT INDEX
	
	LDA #$00	;FOR XAM MODE
	
	TAX		;0->X

SETSTOR: ASL		;LEAVES $7B IF SETTING STOR MODE


SETMODE: STA	MODE	;SET MODE FLAGS
	 CMP  #'.'   	;gak...high bit fix
	 BNE	BLSKIP  ;gak...high bit fix
	 ORA	#$80
	 STA	MODE
	
BLSKIP:	INY		;ADVACE TEXT INDEX


NEXTITEM: 
	LDA	IN,Y	;GET CHARACTER
	CMP	#CR
	BEQ	GETLINE	;WE'RE DONE IF IT'S CR!
	CMP   	#'.'
	BCC   	BLSKIP   ;IGNORE EVERYTHING BELOW "."!
	BEQ	SETMODE  ;SET BLOCK XAM MODE ("."=$AE)
	CMP	#':' 
	BEQ	SETSTOR  ;SET STOR MODE! #BA WILL BECOM $7B
	CMP	#'R'
	BEQ	RUN      ;RUN THE PROGRAM! FORGET THE REST
	STX	L        ;CLEAR INPUT VALUE (X=0)
	STX	H
	STY	YSAV     ;SAVE Y FOR COMPARISON

; HERE WE'RE TRYING TO PARSE A NEW HEX VALUE
NEXTHEX: 
	LDA   IN,Y    ;GET CHARACTER FOR HEX TEXT
	EOR   #$30     ;MAP DIGITS TO 0-9
	CMP   #$0A     ;IS IT A DECIMAL DIGIT?
	BCC   DIG      ;YES!
	ADC   #$88     ;MAP LETTER "A"-"F" TO $FA-FF
	CMP   #$FA     ;HEX LETTER?
	BCC   NOTHEX   ;NO! CHARACTER NOT HEX
DIG:	ASL
	ASL
	ASL
	ASL
	LDX   #$04     ;SHIFT COUNT

HEXSHIFT: 
	ASL          ;HEX DIGIT LEFT, MSB TO CARRY
	ROL   L        ;ROTATE INTO LSD
	ROL   H        ;ROTATE INTO MSD'S
	DEX            ;DONE 4 SHIFTS?
	BNE   HEXSHIFT ;NO, LOOP
	INY            ;ADVANCE TEXT INDEX
	BNE   NEXTHEX  ;ALWAYS TAKEN

NOTHEX:	CPY   YSAV     ;WAS AT LEAST 1 HEX DIGIT GIVEN?
	BEQ   ESCAPE   ;NO! IGNORE ALL, START FROM SCRATCH

	BIT   MODE     ;TEST MODE BYTE	
	BVC   NOTSTOR  ;B6=0 IS STOR, 1 IS XAM OR BLACK XAM

; STOR MODE, SAVE LSD OF NEW HEX BYTE
	LDA   L        ;LSD'S OF HEX DATA
	STA   (STL,X)  ;STORE CUR 'STORE INDEX'(X=0)
	INC   STL      ;INCREMENT STORE INDEX
	BNE   NEXTITEM ;NO CARRY!
	INC   STH      ;ADD CARRY TO 'STORE INDEX' HIGH

TONXTITM: JMP   NEXTITEM ;GET NEXT COMMAND ITEM

; RUN USER'S PROGRAM FROM LAST OPENED LOCATION

RUN:	JSR   ACTRUN   ;RUN USER'S PRORAM	
	JMP   SFTRST
	
ACTRUN:	JMP   (XAML)

; WE'RE NOT IN STORE MODE

NOTSTOR: BMI   XAMNEXT  ;B7=0 FOR XAM, 1 FOR BLOCK XAM

;WE'RE IN XAM MODE NOW
	LDX   #$02      ;COPY 2 BYTES
SETADR:	LDA   L-1,X      ;COPY HEX DATA TO
	STA   STL-1,X    ;store index'
	STA   XAML-1,X   ;AND TO 'XAM INDEX'
	DEX              ;NEXT OF 2 BYTES
	BNE   SETADR     ;LOOP UNLESS X=0

; PRINT ADDR & DATA FROM THIS ADDR, FALL THRU NEXT BNE

NXTPRNT: BNE   PRDATA    ;NE MEANS NO ADDRESS TO PRINT
	LDA   #LF
	JSR   ECHO
	LDA   #CR        ;PRINT CR FIRST
	JSR   ECHO
	LDA   XAMH       ;OUTPUT HIGH-ORDER BYTE OF ADDR
	JSR   PRBYTE
	LDA   XAML       ;OUTPUT LOW-ORDER BYTE OF ADDR
	JSR   PRBYTE
	LDA   #':'       ;PRINT COLON
	JSR   ECHO

PRDATA:	LDA   #' '       ;PRINT SPACE
	JSR   ECHO
	LDA   (XAML,X)   ;GET DATA FROM ADDRESS(X=0)
	JSR   PRBYTE     ;OUTPUT IT IN HEX FORMAT

XAMNEXT: STX   MODE      ;0->MODE(XAM MODE)
	LDA   XAML       ;SEE IF THERE'S MORE TO PRINT
	CMP   L
	LDA   XAMH
	SBC   H
	BCS   TONXTITM   ;NOT LESS! NO MORE DATA TO OUTPUT

	INC   XAML       ;INCREMENT 'EXAMING INDEX'
	BNE   MOD8CHK    ;NO CARRY!
	INC   XAMH

MOD8CHK: LDA   XAML      ;IF ADDRESS MOD8=0 START NEW LINE
	AND   #$07       ;8 VALUES PER ROW
	BPL   NXTPRNT    ;ALWAYS TAKEN

; SUBROUTINE TO PRINT A BYTE IN A IN HEX FORM
PRBYTE:	PHA              ;SAVE A FOR LSD
	LSR
	LSR
	LSR              ;MSD TO LSD
	LSR
	JSR   PRHEX      ;OUTPUT HEX DIGIT
	PLA              ;RESTORE A
	
; FALL THROUGH TO PRINT HEX ROUTING

PRHEX:	AND   #$0F       ;MASK LSD FOR HEX PRINT
	ORA   #'0'       ;ADD "0"
	CMP   #'9'+1     ;DIGIT?
	BCC   ECHO       ;YES, OUTPUT IT
	ADC   #$06       ;ADD OFFSET FOR LETTE
ECHO:	PHA              ;SAVE A
	JSR   COUT	 ;COUT
	PLA              ;RESTORE A
	RTS

SHWMSG:	LDY   #$0

PRINT:	LDA   (MSGL),Y
	BEQ   DONE
	JSR   ECHO
	INY
	BNE   PRINT
DONE:	RTS

MSG1:
	.byte  CR,LF
	.BYTE   "WELCOME TO GAKMON V1.0"
	.BYTE  CR,LF
	.BYTE   "    By Glenn Klaas"
	.byte  CR,LF,CR,LF,0	

;****************************
;***** Monitor Routines *****
;****************************
	.ORG	$FF00
COUT:
	STA	io_putc
	RTS
	
	.ORG	$FF1F
RDKEY:	LDA 	io_getc
	BEQ 	RDKEY
	RTS
	
ca65 V2.13.3 - (C) Copyright 1998-2012 Ullrich von Bassewitz
Main file   : gaksbc.s
Current file: gaksbc.s

000000r 1               ;GAKMON v1.0 - 6502 Monitor
000000r 1               
000000r 1               .debuginfo +
000000r 1               .setcpu "6502"
000000r 1               
000000r 1               ;-------------------------------------------------------------------------
000000r 1               ;  ACIA ADDRESSES
000000r 1               ;-------------------------------------------------------------------------
000000r 1               
000000r 1               ACIA 		:= $A000	;BASE ADDRESS OF THE MC68B50P
000000r 1               ACIAControl 	:= ACIA+0	; Set operational parameters (w)
000000r 1               ACIAStatus 	:= ACIA+0	; Indicates if char has been received (r)
000000r 1               ACIAData 	:= ACIA+1	; Data being recieved (r) or sent (w)
000000r 1               
000000r 1               ;-------------------------------------------------------------------------
000000r 1               ;  VARIABLES
000000r 1               ;-------------------------------------------------------------------------
000000r 1               
000000r 1               XAML		= $10		;LAST "OPENED" LOCATION LOW
000000r 1               XAMH		= $11		;LAST "OPENED" LOCATION HIGH
000000r 1               STL		= $12		;STORE ADDRESS LOW
000000r 1               STH		= $13		;STORE ADDRESS HIGH
000000r 1               L		= $14		;HEX VALUE PARSING LOW
000000r 1               H		= $15		;HEX VALUE PARSING HIGH
000000r 1               YSAV		= $16		;USED TO SEE IF HEX VALUE IS GIVEN
000000r 1               MODE		= $17		;$00=XAM, $7F=STOR, $AE=BLOCK XAM
000000r 1               STRL		= $18		;STRING START ADDRESS
000000r 1               STRH		= $19		;STRING END ADDRESS
000000r 1               IN		= $200		;INPUT BUFFER
000000r 1               
000000r 1               ;-------------------------------------------------------------------------
000000r 1               ;  CONSTANTS
000000r 1               ;-------------------------------------------------------------------------
000000r 1               
000000r 1               BS		= $08		;CODE-BACKSPACE KEY
000000r 1               CR		= $0D		;CODE-CARRIAGE RETURN
000000r 1               LF		= $0A 		;CODE-LINE FEED
000000r 1               ESC		= $1B		;CODE-ESC KEY
000000r 1               PROMPT		= '*'		;PROMPT
000000r 1               STACK_TOP	= $FF		;TOP OF THE STACK
000000r 1               
000000r 1               ;-------------------------------------------------------------------------
000000r 1               ;  INITIAL SETUP
000000r 1               ;-------------------------------------------------------------------------
000000r 1               
000000r 1               .segment "CODE"
000000r 1               .org $C000
00C000  1               
00C000  1  D8           RESET:	CLD 			;CLEAR DECIMAL MODE
00C001  1  A2 FF        	LDX #STACK_TOP		;SET THE TOP OF STACK VALUE
00C003  1  9A           	TXS			;INITIALIZE STACK
00C004  1  A9 95        	LDA #$95      		;Set ACIA:CLK/16,8-bits,1 stop
00C006  1               				;  RTS low TX INT disabled
00C006  1  8D 00 A0     	STA ACIAControl		;INITIALIZE THE ACIA
00C009  1               
00C009  1               ;DISPLAY WELCOME MESSAGE
00C009  1  A9 26        	LDA #<MSG1		;DETERMINE LOW
00C00B  1  85 18        	STA STRL		;SET LOW
00C00D  1  A9 C1        	LDA #>MSG1		;DETERMINE HI
00C00F  1  85 19        	STA STRH		;SET HI
00C011  1  20 0E C1        	JSR SHWMSG		;SHOW WELCOME
00C014  1               
00C014  1               ;-------------------------------------------------------------------------
00C014  1               ;  COMMAND INPUT PROCESSING
00C014  1               ;-------------------------------------------------------------------------
00C014  1               
00C014  1  A9 1B        SFTRST:	LDA #ESC       		;AUTO ESCAPE
00C016  1  C9 08        NOTCR:	CMP #BS        		;BACKSPACE KEY?
00C018  1  F0 11        	BEQ BAKSPACE   		;YES
00C01A  1  C9 1B        	CMP #ESC       		;ESC?
00C01C  1  F0 03        	BEQ ESCAPE     		;YES
00C01E  1  C8           	INY            		;ADVANCE TEXT INDEX
00C01F  1  10 17        	BPL NEXTCHAR   		;IF LINE LONGER THAN 127 FALL THRU
00C021  1               
00C021  1  A9 2A        ESCAPE:	LDA #PROMPT    		;PRINT PROMPT CHARACTER
00C023  1  20 08 C1     	JSR ECHO       		;OUTPUT IT
00C026  1               
00C026  1  20 1B C1     GETLINE: JSR CRLF		;SEND CRLF TO SCREEN
00C029  1               
00C029  1  A0 01        	LDY #$01       		;INITIALIZE TEXT INDEX
00C02B  1  88           BAKSPACE: DEY
00C02C  1  30 F8        	BMI GETLINE    		;REINIT BEYOND START OF LINE
00C02E  1  A9 20        	LDA #' '       		;SPACE, OVERWITE CHAR
00C030  1  20 08 C1     	JSR ECHO
00C033  1  A9 08        	LDA #BS        		;BACKSPACE AGAIN
00C035  1  20 08 C1     	JSR ECHO
00C038  1               
00C038  1  20 1F FF     NEXTCHAR: JSR RDKEY    		;WAIT FOR KEYPRESS
00C03B  1  99 00 02     	STA IN,Y       		;ADD TO TEXT BUFFER
00C03E  1  20 08 C1     	JSR ECHO       		;DISPLAY CHARACTER
00C041  1               	;JSR PRBYTE    		;DEBUG - PRINT HEX KEYVALUE
00C041  1  C9 0D        	CMP #CR        		;CR?
00C043  1  D0 D1        	BNE NOTCR      		;NO.
00C045  1               
00C045  1               ;-------------------------------------------------------------------------
00C045  1               ;  COMMAND EXECUTION PROCESSING
00C045  1               ;-------------------------------------------------------------------------
00C045  1               
00C045  1  A0 FF        	LDY #$FF       		;RESET TEXT INDEX
00C047  1  A9 00        	LDA #$00       		;DEFAULT TO EXAMINE MODE
00C049  1  AA           	TAX            		;0->X
00C04A  1               
00C04A  1  0A           SETSTOR: ASL			;LEAVES $74 IF SETTING STOR MODE
00C04B  1               
00C04B  1  85 17        SETMODE: STA MODE		;SET MODE FLAGS
00C04D  1  C9 2E            CMP #'.'			;are we setting block xam?
00C04F  1  D0 04        	BNE BLSKIP			;no, continue
00C051  1  09 80        	ORA #$80			;yes, set the high bit
00C053  1  85 17        	STA MODE			;update mode
00C055  1               
00C055  1  C8           BLSKIP:	INY			;ADVACE TEXT INDEX
00C056  1               
00C056  1  B9 00 02     NEXTITEM: LDA IN,Y		;GET CHARACTER
00C059  1  C9 0D        	CMP #CR
00C05B  1  F0 C9        	BEQ GETLINE		;WE'RE DONE IF IT'S CR!
00C05D  1  C9 2E        	CMP #'.'		; $2E 00101110
00C05F  1  90 F4        	BCC BLSKIP		;IGNORE EVERYTHING LESS THAN "."!
00C061  1  F0 E8        	BEQ SETMODE		;IF EQ, SET BLOCK XAM MODE ("."=$2E)
00C063  1  C9 3A        	CMP #':'		; $3A 00111010
00C065  1  F0 E3        	BEQ SETSTOR		;SET STOR MODE! #$3A WILL BECOM $74
00C067  1  C9 52        	CMP #'R'
00C069  1  F0 3E        	BEQ RUN			;RUN THE PROGRAM! FORGET THE REST
00C06B  1  86 14        	STX L			;CLEAR INPUT VALUE (X=0)
00C06D  1  86 15        	STX H
00C06F  1  84 16        	STY YSAV		;SAVE Y FOR COMPARISON
00C071  1               
00C071  1               ; HERE WE'RE TRYING TO PARSE A NEW HEX VALUE
00C071  1               
00C071  1  B9 00 02     NEXTHEX: LDA IN,Y		;GET CHARACTER FOR HEX TEST
00C074  1  49 30        	EOR #$30		;MAP DIGITS 0-9
00C076  1  C9 0A        	CMP #$0A		;IS IT A DECIMAL DIGIT?
00C078  1  90 06        	BCC DIG			;YES, PROCESS THE DIGIT
00C07A  1  69 88        	ADC #$88		;MAP LETTER "A"-"F" TO $FA-FF
00C07C  1  C9 FA        	CMP #$FA		;IS IT A HEX LETTER?
00C07E  1  90 11        	BCC NOTHEX		;NO, CHARACTER NOT HEX OR CONTINUE
00C080  1               
00C080  1  0A           DIG:	ASL
00C081  1  0A           	ASL			;HEX DIGIT TO MSD OF A
00C082  1  0A           	ASL
00C083  1  0A           	ASL
00C084  1               
00C084  1  A2 04        	LDX #$04		;SHIFT COUNT
00C086  1  0A           HEXSHIFT: ASL			;HEX DIGIT LEFT, MSB TO CARRY
00C087  1  26 14        	ROL L			;ROTATE INTO LSD
00C089  1  26 15        	ROL H			;ROTATE INTO MSD'S
00C08B  1  CA           	DEX			;DONE 4 SHIFTS?
00C08C  1  D0 F8        	BNE HEXSHIFT		;NO, LOOP
00C08E  1  C8           	INY			;ADVANCE TEXT INDEX
00C08F  1  D0 E0        	BNE NEXTHEX		;ALWAYS TAKEN
00C091  1               
00C091  1  C4 16        NOTHEX:	CPY YSAV		;WAS AT LEAST 1 HEX DIGIT GIVEN?
00C093  1  D0 03        	BNE NOESCAPE		;NO! IGNORE ALL,START FROM SCRATCH
00C095  1  4C 21 C0     	JMP ESCAPE
00C098  1               
00C098  1  24 17        NOESCAPE: BIT MODE
00C09A  1  50 16        	BVC NOTSTOR
00C09C  1  A5 14        	LDA L			;LSD'S OF HEX DATA
00C09E  1  81 12        	STA (STL,X)		;STORE CUR 'STORE INDEX'(X=0)
00C0A0  1  E6 12        	INC STL			;INCREMENT STORE INDEX
00C0A2  1  D0 B2        	BNE NEXTITEM		;NO CARRY!
00C0A4  1  E6 13        	INC STH			;ADD CARRY TO 'STORE INDEX' HIGH
00C0A6  1  4C 56 C0     TONXTITM: JMP NEXTITEM		;GET NEXT COMMAND ITEM
00C0A9  1               
00C0A9  1               ;-------------------------------------------------------------------------
00C0A9  1               ;  RUN USERS PROGRAM FROM THE LAST OPENED LOCATION
00C0A9  1               ;-------------------------------------------------------------------------
00C0A9  1               
00C0A9  1  20 AF C0     RUN:	JSR ACTRUN		;RUN USER'S PRORAM
00C0AC  1  4C 14 C0     	JMP SFTRST		;SOFT RESET ON RETURN
00C0AF  1               
00C0AF  1  6C 10 00     ACTRUN:	JMP (XAML)
00C0B2  1               
00C0B2  1               ;-------------------------------------------------------------------------
00C0B2  1               ;  We're not in Store mode
00C0B2  1               ;-------------------------------------------------------------------------
00C0B2  1               
00C0B2  1  30 29        NOTSTOR:	BMI XAMNEXT	;B7=0 FOR XAM, 1 FOR BLOCK XAM
00C0B4  1               
00C0B4  1               ;WE'RE IN XAM MODE NOW
00C0B4  1               
00C0B4  1  A2 02        	LDX #$02		;COPY 2 BYTES
00C0B6  1  B5 13        SETADR:	LDA L-1,X		;COPY HEX DATA TO
00C0B8  1  95 11        	STA STL-1,X		;store index'
00C0BA  1  95 0F        	STA XAML-1,X		;AND TO 'XAM INDEX'
00C0BC  1  CA           	DEX			;NEXT OF 2 BYTES
00C0BD  1  D0 F7        	BNE SETADR		;LOOP UNLESS X=0
00C0BF  1               
00C0BF  1               ; PRINT ADDR & DATA FROM THIS ADDR, FALL THRU NEXT BNE
00C0BF  1               
00C0BF  1  D0 12        NXTPRNT:	BNE PRDATA	;NE MEANS NO ADDRESS TO PRINT
00C0C1  1  20 1B C1     	JSR CRLF
00C0C4  1  A5 11        	LDA XAMH		;OUTPUT HIGH-ORDER BYTE OF ADDR
00C0C6  1  20 F5 C0     	JSR PRBYTE
00C0C9  1  A5 10        	LDA XAML		;OUTPUT LOW-ORDER BYTE OF ADDR
00C0CB  1  20 F5 C0     	JSR PRBYTE
00C0CE  1  A9 3A        	LDA #':'		;PRINT COLON
00C0D0  1  20 08 C1     	JSR ECHO
00C0D3  1               
00C0D3  1  A9 20        PRDATA:	LDA #' '		;PRINT SPACE
00C0D5  1  20 08 C1     	JSR ECHO
00C0D8  1  A1 10        	LDA (XAML,X)		;GET DATA FROM ADDRESS(X=0)
00C0DA  1  20 F5 C0     	JSR PRBYTE		;OUTPUT IT IN HEX FORMAT
00C0DD  1  86 17        XAMNEXT:	STX MODE	;0->MODE(XAM MODE)
00C0DF  1  A5 10        	LDA XAML		;SEE IF THERE'S MORE TO PRINT
00C0E1  1  C5 14        	CMP L
00C0E3  1  A5 11        	LDA XAMH
00C0E5  1  E5 15        	SBC H
00C0E7  1  B0 BD        	BCS TONXTITM		;NOT LESS! NO MORE DATA TO OUTPUT
00C0E9  1               
00C0E9  1  E6 10        	INC XAML		;INCREMENT 'EXAMING INDEX'
00C0EB  1  D0 02        	BNE MOD8CHK		;NO CARRY!
00C0ED  1  E6 11        	INC XAMH
00C0EF  1               
00C0EF  1  A5 10        MOD8CHK:	LDA XAML	;IF ADDRESS MOD8=0 START NEW LINE
00C0F1  1  29 07        	AND #%00000111		;8 VALUES PER ROW
00C0F3  1  10 CA        	BPL NXTPRNT		;ALWAYS TAKEN
00C0F5  1               
00C0F5  1               ;-------------------------------------------------------------------------
00C0F5  1               ;  Subroutine to print a byte in A in hex form (destructive)
00C0F5  1               ;-------------------------------------------------------------------------
00C0F5  1               
00C0F5  1  48           PRBYTE:	PHA			;SAVE A FOR LSD
00C0F6  1  4A           	LSR
00C0F7  1  4A           	LSR
00C0F8  1  4A           	LSR			;MSD TO LSD
00C0F9  1  4A           	LSR
00C0FA  1  20 FE C0     	JSR PRHEX		;OUTPUT HEX DIGIT
00C0FD  1  68           	PLA			;RESTORE A
00C0FE  1               
00C0FE  1               ; FALL THROUGH TO PRINT HEX ROUTING
00C0FE  1               
00C0FE  1               ;-------------------------------------------------------------------------
00C0FE  1               ;  Subroutine to print a hexadecimal digit
00C0FE  1               ;-------------------------------------------------------------------------
00C0FE  1               
00C0FE  1  29 0F        PRHEX:	AND #$0F		;MASK LSD FOR HEX PRINT
00C100  1  09 30        	ORA #'0'		;ADD "0"
00C102  1  C9 3A        	CMP #'9'+1		;DIGIT?
00C104  1  90 02        	BCC ECHO		;YES, OUTPUT IT
00C106  1  69 06        	ADC #$06		;ADD OFFSET FOR LETTER
00C108  1               
00C108  1               ; Fall through to print routine
00C108  1               
00C108  1               ;-------------------------------------------------------------------------
00C108  1               ;  Subroutine to print a character to the terminal
00C108  1               ;-------------------------------------------------------------------------
00C108  1               
00C108  1  48           ECHO:	PHA			;PUSH A TO STACK
00C109  1  20 00 FF     	JSR COUT		;COUT
00C10C  1  68             	PLA			;PULL A FROM STACK
00C10D  1  60           	RTS
00C10E  1               
00C10E  1  A0 00        SHWMSG:	LDY #$0			;INITIALIZE COUNTER
00C110  1  B1 18        PRINT:	LDA (STRL),Y		;LOAD NEXT CHAR
00C112  1  F0 06        	BEQ DONE		;GOTO DONE IF 0, ELSE
00C114  1  20 08 C1     	JSR ECHO		;SEND CHAR TO SCREEN
00C117  1  C8           	INY			;INCREMENT COUNTER
00C118  1  D0 F6        	BNE PRINT		;LOOP FOR NEXT CHAR
00C11A  1  60           DONE:	RTS			;RETURN TO CALLER
00C11B  1               
00C11B  1  A9 0A        CRLF:	LDA #LF
00C11D  1  20 08 C1     	JSR ECHO		;SEND LF
00C120  1  A9 0D        	LDA #CR
00C122  1  20 08 C1     	JSR ECHO		;SEND CR
00C125  1  60           	RTS
00C126  1               
00C126  1  0D 0A        MSG1:	.byte CR,LF
00C128  1  57 45 4C 43  	.byte "WELCOME TO GAKMON V1.0"
00C12C  1  4F 4D 45 20  
00C130  1  54 4F 20 47  
00C13E  1  0D 0A        	.byte CR,LF
00C140  1  20 20 20 20  	.byte "    By Glenn Klaas"
00C144  1  42 79 20 47  
00C148  1  6C 65 6E 6E  
00C152  1  0D 0A 0D 0A  	.byte CR,LF,CR,LF,0
00C156  1  00           
00C157  1               
00C157  1               ;-------------------------------------------------------------------------
00C157  1               ; CORE IO HANDLING ROUTINES
00C157  1               ;-------------------------------------------------------------------------
00C157  1               
00C157  1               .segment "IOHANDLER"
00C157  1               .org $FF00
00FF00  1               
00FF00  1  48           COUT:	PHA
00FF01  1  AD 00 A0     ACIAWAIT:	LDA ACIAStatus
00FF04  1  29 02        	AND #2			;MASK TDRE
00FF06  1  C9 02        	CMP #2
00FF08  1  D0 F7        	BNE ACIAWAIT
00FF0A  1  68           	PLA
00FF0B  1  8D 01 A0     	STA ACIAData
00FF0E  1  60           	RTS
00FF0F  1               
00FF0F  1  AD 00 A0     MONRDKEY: LDA ACIAStatus
00FF12  1  29 01        	AND #1			;MASK RDRF
00FF14  1  C9 01        	CMP #1
00FF16  1  D0 05        	BNE NoDataIn
00FF18  1  AD 01 A0     	LDA ACIAData
00FF1B  1  38           	SEC			; Carry set if key available
00FF1C  1  60           	RTS
00FF1D  1  18           NoDataIn:	CLC		; Carry clear if no key pressed
00FF1E  1  60           	RTS
00FF1F  1               
00FF1F  1  20 0F FF     RDKEY:	JSR MONRDKEY		;Check if key was pressed
00FF22  1  90 FB        	BCC RDKEY		;If not, check again
00FF24  1  60           	RTS
00FF25  1               
00FF25  1               ;-------------------------------------------------------------------------
00FF25  1               ;  Vector area
00FF25  1               ;-------------------------------------------------------------------------
00FF25  1               
00FF25  1               .segment "VECTS"
00FF25  1               .org $FFFA
00FFFA  1  00 C0        	.word RESET		;NMI
00FFFC  1  00 C0        	.word RESET		;RESET
00FFFE  1  00 C0        	.word RESET		;IRQ
00FFFE  1               
